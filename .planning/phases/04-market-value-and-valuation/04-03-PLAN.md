---
phase: 04-market-value-and-valuation
plan: 03
type: execute
wave: 2
depends_on: [04-01, 04-02]
files_modified:
  - src/app/lease/actions.ts
  - src/app/lease/[id]/compare/page.tsx
  - src/components/comparison/ComparisonView.tsx

autonomous: true

must_haves:
  truths:
    - "Server action createMarketValue inserts a new market_values record and revalidates the comparison page"
    - "Server action getLatestMarketValue returns the most recent market value for a lease"
    - "Comparison page fetches latest market value and passes it to getComparisonData"
    - "When no market value exists, comparison page passes undefined (not residualValue)"
    - "After saving market value, comparison results update immediately (revalidatePath)"
  artifacts:
    - path: "src/app/lease/actions.ts"
      provides: "createMarketValue and getLatestMarketValue server actions"
      exports: ["createMarketValue", "getLatestMarketValue"]
    - path: "src/app/lease/[id]/compare/page.tsx"
      provides: "Comparison page with market value data fetching"
      contains: "getLatestMarketValue"
  key_links:
    - from: "src/app/lease/actions.ts"
      to: "src/lib/db/schema.ts"
      via: "marketValues table insert/select"
      pattern: "marketValues"
    - from: "src/app/lease/[id]/compare/page.tsx"
      to: "src/app/lease/actions.ts"
      via: "getLatestMarketValue call"
      pattern: "getLatestMarketValue"
    - from: "src/app/lease/[id]/compare/page.tsx"
      to: "src/lib/calculations/evaluate-all.ts"
      via: "getComparisonData with estimatedSalePrice"
      pattern: "getComparisonData.*estimatedSalePrice"
---

<objective>
Wire the data layer to the application: server actions for creating/fetching market values, and update the comparison page to use real market value data in calculations.

Purpose: Connects the database schema (Plan 01) and calculation logic (Plan 02) into the running application. This is the plumbing that makes market value entry functional.
Output: Server actions for market value CRUD, comparison page fetches and uses market value.
</objective>

<execution_context>
@/Users/brandonharvey/.claude/get-shit-done/workflows/execute-plan.md
@/Users/brandonharvey/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/04-market-value-and-valuation/04-CONTEXT.md
@.planning/phases/04-market-value-and-valuation/04-01-SUMMARY.md
@.planning/phases/04-market-value-and-valuation/04-02-SUMMARY.md
@src/app/lease/actions.ts
@src/app/lease/[id]/compare/page.tsx
@src/lib/db/schema.ts
@src/lib/db/client.ts
@src/lib/calculations/evaluate-all.ts
@src/lib/validations/market-value-schema.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Market value server actions</name>
  <files>src/app/lease/actions.ts</files>
  <action>
    Add market value server actions to the existing `src/app/lease/actions.ts` file. Do NOT replace existing actions -- append these new ones.

    **1. Add imports:**
    - `import { marketValues } from '@/lib/db/schema';`
    - `import { marketValueSchema } from '@/lib/validations/market-value-schema';`
    - `import { desc } from 'drizzle-orm';` (add to existing drizzle-orm import)

    **2. createMarketValue action:**
    ```typescript
    export async function createMarketValue(
      leaseId: string,
      data: { value: number; source?: string; sourceLabel?: string }
    ): Promise<ActionResult<{ id: string }>> {
    ```
    - Validate input with `marketValueSchema.safeParse(data)`
    - On validation failure, return `{ success: false, error, fieldErrors }`
    - Convert value to Decimal: `new Decimal(validated.value.toString())`
    - Insert into `marketValues` table with leaseId, value, source (default 'manual'), sourceLabel (default 'Your estimate')
    - Use `.returning({ id: marketValues.id })` to get the inserted ID
    - Call `revalidatePath(\`/lease/${leaseId}/compare\`)` for instant update
    - Return `{ success: true, data: { id } }`
    - Wrap in try/catch following existing pattern

    **3. getLatestMarketValue action:**
    ```typescript
    export async function getLatestMarketValue(leaseId: string) {
    ```
    - Query `marketValues` where `leaseId` matches
    - `orderBy(desc(marketValues.createdAt))`
    - `.limit(1)`
    - Return first result or null
    - Wrap in try/catch, return null on error (consistent with getLease pattern)

    **4. getMarketValueHistory action (lightweight, for future use):**
    ```typescript
    export async function getMarketValueHistory(leaseId: string) {
    ```
    - Query all `marketValues` for leaseId, ordered by `createdAt` desc
    - Return array (empty on error)
    - Limit to last 20 entries to prevent over-fetching
  </action>
  <verify>
    - `npx tsc --noEmit` passes
    - The three new exports are accessible: `createMarketValue`, `getLatestMarketValue`, `getMarketValueHistory`
    - Existing actions (createLease, updateLease, deleteLease, getLease, getLeases) still exist unchanged
  </verify>
  <done>
    - createMarketValue validates input, inserts record, revalidates comparison page
    - getLatestMarketValue returns most recent market value or null
    - getMarketValueHistory returns last 20 entries ordered newest first
    - All actions follow existing error handling pattern (ActionResult type)
  </done>
</task>

<task type="auto">
  <name>Task 2: Comparison page market value integration</name>
  <files>src/app/lease/[id]/compare/page.tsx</files>
  <action>
    Update the comparison page server component to fetch market value and pass it to the evaluation function.

    **1. Add import:**
    - `import { getLatestMarketValue } from '@/app/lease/actions';`
    - `import { Decimal } from '@/lib/decimal';`

    **2. Fetch market value in page component:**
    After fetching the lease and before calling `getComparisonData`, add:
    ```typescript
    const latestMarketValue = await getLatestMarketValue(id);
    const estimatedSalePrice = latestMarketValue
      ? new Decimal(latestMarketValue.value.toString())
      : undefined;
    ```

    **3. Pass to getComparisonData:**
    Change `getComparisonData(lease)` to `getComparisonData(lease, estimatedSalePrice)`.

    **4. Pass market value info to ComparisonView:**
    Add props to ComparisonView:
    - `marketValue={latestMarketValue}` -- the full DB record (for display, staleness, source label)
    - `leaseId={id}` -- needed for server action calls from child components

    The ComparisonView will need to accept these new props. Update the JSX:
    ```tsx
    <ComparisonView
      data={comparisonData}
      marketValue={latestMarketValue}
      leaseId={id}
    />
    ```

    **5. Update ComparisonView props interface:**
    In `src/components/comparison/ComparisonView.tsx`, update the interface to accept the new optional props. Import `MarketValue` type from schema. For now, just accept the props and pass them through -- the UI components that consume them will be built in Plan 04.

    Update ComparisonViewProps:
    ```typescript
    interface ComparisonViewProps {
      data: ComparisonData;
      marketValue?: MarketValue | null;
      leaseId: string;
    }
    ```

    Destructure these new props in the component but don't use them yet (Plan 04 adds the UI components). Add a placeholder comment: `{/* Market value display will be added in Plan 04 */}`.
  </action>
  <verify>
    - `npx tsc --noEmit` passes
    - `npm run build` succeeds (catches RSC/client boundary issues)
    - Comparison page renders without errors when no market value exists (null path)
    - ComparisonView accepts the new props without breaking existing layout
  </verify>
  <done>
    - Comparison page fetches latest market value from database
    - estimatedSalePrice is passed to getComparisonData (or undefined if none exists)
    - Market value DB record and leaseId passed to ComparisonView as props
    - ComparisonView interface updated to accept market value props
    - No visual changes yet (UI components come in Plan 04)
  </done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes
- `npm run build` succeeds
- Comparison page loads successfully for a lease with no market value (no crash)
- Server actions are exported correctly from actions.ts
</verification>

<success_criteria>
- Market value server actions exist and are functional (create, get latest, get history)
- Comparison page integrates market value into evaluation pipeline
- Missing market value handled gracefully (passes undefined, not residualValue)
- No regressions in existing comparison functionality
</success_criteria>

<output>
After completion, create `.planning/phases/04-market-value-and-valuation/04-03-SUMMARY.md`
</output>
