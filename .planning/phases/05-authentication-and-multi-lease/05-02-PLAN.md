---
phase: 05-authentication-and-multi-lease
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/db/schema.ts
  - drizzle/migrations/XXXX_users_and_user_id.sql
autonomous: true

must_haves:
  truths:
    - "A users table exists in the database schema with Clerk user ID as primary key"
    - "The leases table has a userId column referencing the users table"
    - "Cascade delete is configured so deleting a user removes their leases"
    - "Relations are defined between users, leases, and marketValues"
  artifacts:
    - path: "src/lib/db/schema.ts"
      provides: "users table, userId column on leases, updated relations"
      contains: "users"
    - path: "drizzle/migrations/"
      provides: "SQL migration file for users table and user_id column"
  key_links:
    - from: "leases.userId"
      to: "users.id"
      via: "foreign key reference with cascade delete"
      pattern: "references.*users\\.id.*cascade"
    - from: "usersRelations"
      to: "leases"
      via: "Drizzle relations one-to-many"
      pattern: "usersRelations"
---

<objective>
Add users table and user_id foreign key to leases table in the database schema, then generate a Drizzle migration.

Purpose: User-scoped data isolation requires every lease to be owned by a user. This schema change is the foundation for all auth-aware queries.
Output: Updated schema.ts with users table and user_id FK, plus generated migration SQL.
</objective>

<execution_context>
@/Users/brandonharvey/.claude/get-shit-done/workflows/execute-plan.md
@/Users/brandonharvey/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-authentication-and-multi-lease/05-RESEARCH.md
@src/lib/db/schema.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add users table and user_id FK to schema</name>
  <files>src/lib/db/schema.ts</files>
  <action>
    1. Add `users` table to schema.ts (BEFORE the leases table definition):
       ```typescript
       export const users = pgTable('users', {
         id: text('id').primaryKey(), // Clerk user ID (string, not UUID)
         email: varchar('email', { length: 255 }).notNull(),
         firstName: varchar('first_name', { length: 100 }),
         lastName: varchar('last_name', { length: 100 }),
         createdAt: timestamp('created_at').notNull().defaultNow(),
         updatedAt: timestamp('updated_at').notNull().defaultNow(),
       });
       ```
       - Use `text('id')` as primary key (Clerk IDs are strings like `user_2abc...`, NOT UUIDs)
       - Include email (notNull), firstName (nullable), lastName (nullable)
       - Standard audit timestamps

    2. Add `userId` column to leases table:
       - Add `userId: text('user_id').references(() => users.id, { onDelete: 'cascade' })` to the leases table
       - Make it NULLABLE for now (existing leases have no user). Plan 03 will handle the migration strategy.
       - Place it right after the `id` field for readability
       - `onDelete: 'cascade'` ensures deleting a user cascades to their leases (which further cascades to marketValues via existing FK)

    3. Add type exports:
       ```typescript
       export type User = typeof users.$inferSelect;
       export type NewUser = typeof users.$inferInsert;
       ```

    4. Update relations:
       - Add `usersRelations` defining `many(leases)`
       - Update `leasesRelations` to include `one(users, { fields: [leases.userId], references: [users.id] })`
       - Keep existing `many(marketValues)` in leasesRelations

    Decision: userId is NULLABLE initially. Existing leases created before auth have no user. Multi-step migration: nullable first, then populate during first login, then (optionally) make NOT NULL later. For this personal-use MVP, we'll adopt a "fresh start" approach -- existing test leases can be deleted or claimed by first user.
  </action>
  <verify>
    - `src/lib/db/schema.ts` contains `export const users = pgTable('users'`
    - `src/lib/db/schema.ts` contains `userId: text('user_id')` in leases table
    - `src/lib/db/schema.ts` contains `usersRelations`
    - TypeScript compilation: `npx tsc --noEmit` passes
  </verify>
  <done>Schema has users table with Clerk-compatible text ID, leases table has nullable userId FK with cascade delete, and all relations are defined</done>
</task>

<task type="auto">
  <name>Task 2: Generate database migration</name>
  <files>drizzle/migrations/</files>
  <action>
    1. Generate migration using Drizzle Kit:
       ```bash
       npx drizzle-kit generate
       ```
       This will produce a SQL migration file in `drizzle/migrations/` that:
       - Creates the `users` table
       - Adds `user_id` column to `leases` table (nullable)
       - Adds foreign key constraint from `leases.user_id` to `users.id` with CASCADE delete

    2. Review the generated SQL to verify:
       - `CREATE TABLE "users"` with correct column types
       - `ALTER TABLE "leases" ADD COLUMN "user_id" text` (no NOT NULL)
       - `ALTER TABLE "leases" ADD CONSTRAINT ... REFERENCES "users"("id") ON DELETE cascade`

    Note: Migration will NOT be applied (pushed) in this plan. That happens when the user runs `npx drizzle-kit migrate` or `npx drizzle-kit push` after Clerk is configured. The migration is generated so it's ready.
  </action>
  <verify>
    - New migration file exists in `drizzle/migrations/`
    - Migration SQL contains `CREATE TABLE` for users
    - Migration SQL contains `ALTER TABLE "leases"` adding user_id column
  </verify>
  <done>Migration SQL is generated and ready to apply. Users table will be created and leases table will gain a nullable user_id FK</done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes with updated schema
- `src/lib/db/schema.ts` exports users, User, NewUser types
- `src/lib/db/schema.ts` has userId on leases with cascade delete reference to users
- A new migration file exists in drizzle/migrations/
</verification>

<success_criteria>
Database schema includes users table and leases.userId FK. Migration is generated and ready to apply. All TypeScript types compile cleanly.
</success_criteria>

<output>
After completion, create `.planning/phases/05-authentication-and-multi-lease/05-02-SUMMARY.md`
</output>
