---
phase: 05-authentication-and-multi-lease
plan: 03
type: execute
wave: 2
depends_on: ["05-01", "05-02"]
files_modified:
  - src/app/api/webhooks/clerk/route.ts
  - src/app/lease/actions.ts
autonomous: true

must_haves:
  truths:
    - "Clerk webhook events (user.created, user.updated, user.deleted) sync user data to local database"
    - "Webhook signatures are verified using Svix before processing"
    - "Every Server Action that touches lease data verifies auth() and scopes queries to the authenticated user"
    - "Creating a lease associates it with the authenticated user's ID"
    - "Users can only read, update, and delete their own leases"
  artifacts:
    - path: "src/app/api/webhooks/clerk/route.ts"
      provides: "Webhook handler for Clerk user lifecycle events"
      exports: ["POST"]
    - path: "src/app/lease/actions.ts"
      provides: "Auth-gated, user-scoped Server Actions"
      exports: ["createLease", "updateLease", "deleteLease", "getLease", "getLeases"]
  key_links:
    - from: "src/app/api/webhooks/clerk/route.ts"
      to: "src/lib/db/schema.ts (users table)"
      via: "Drizzle insert/update/delete on users table"
      pattern: "db\\.(insert|delete).*users"
    - from: "src/app/lease/actions.ts"
      to: "@clerk/nextjs/server (auth)"
      via: "auth() call at top of every action"
      pattern: "await auth\\(\\)"
    - from: "src/app/lease/actions.ts"
      to: "src/lib/db/schema.ts (leases table)"
      via: "User-scoped WHERE clause on all queries"
      pattern: "eq.*leases\\.userId.*userId"
---

<objective>
Create the Clerk webhook handler for user sync and add authentication gates to all Server Actions so lease data is user-scoped.

Purpose: This secures all data access. Without auth gates in Server Actions, middleware alone is insufficient (Server Actions can be called from unprotected contexts). The webhook ensures user records exist in the local database for foreign key integrity.
Output: Webhook endpoint that syncs Clerk users to local DB, and all lease Server Actions require authentication and scope queries to the authenticated user.
</objective>

<execution_context>
@/Users/brandonharvey/.claude/get-shit-done/workflows/execute-plan.md
@/Users/brandonharvey/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-authentication-and-multi-lease/05-RESEARCH.md
@.planning/phases/05-authentication-and-multi-lease/05-01-SUMMARY.md
@.planning/phases/05-authentication-and-multi-lease/05-02-SUMMARY.md
@src/app/lease/actions.ts
@src/lib/db/schema.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Clerk webhook handler</name>
  <files>src/app/api/webhooks/clerk/route.ts</files>
  <action>
    Create `src/app/api/webhooks/clerk/route.ts` with a POST handler:

    1. Import `Webhook` from `svix`, `headers` from `next/headers`, `db` from `@/lib/db/client`, `users` from `@/lib/db/schema`, `eq` from `drizzle-orm`

    2. Read `CLERK_WEBHOOK_SIGNING_SECRET` from `process.env`. If missing, return 500 with error message.

    3. Extract Svix headers from the request: `svix-id`, `svix-timestamp`, `svix-signature`. If any missing, return 400.

    4. Get request body as JSON, stringify it, then verify using `new Webhook(secret).verify(body, headers)`. If verification fails, return 400.

    5. Handle events based on `evt.type`:
       - `user.created` and `user.updated`: Upsert into users table using `db.insert(users).values({ id, email, firstName, lastName }).onConflictDoUpdate({ target: users.id, set: { email, firstName, lastName, updatedAt: new Date() } })`. Extract email from `evt.data.email_addresses[0]?.email_address`, firstName from `evt.data.first_name`, lastName from `evt.data.last_name`, id from `evt.data.id`.
       - `user.deleted`: Delete from users table where id matches `evt.data.id`. Cascade will handle leases and market values.

    6. Return 200 with `{ success: true }`.

    IMPORTANT: This route is excluded from middleware protection (configured in Plan 01). Webhook verification via Svix is the security mechanism, not session auth.

    Decision: Use upsert pattern (ON CONFLICT DO UPDATE) to handle race conditions where user accesses app before webhook arrives.
  </action>
  <verify>
    - File exists at `src/app/api/webhooks/clerk/route.ts`
    - File exports a POST function
    - File imports `Webhook` from `svix`
    - File contains `onConflictDoUpdate` for upsert pattern
    - `npx tsc --noEmit` passes
  </verify>
  <done>Webhook handler verifies Svix signatures and upserts/deletes users in local database based on Clerk lifecycle events</done>
</task>

<task type="auto">
  <name>Task 2: Add auth gates and user scoping to all Server Actions</name>
  <files>src/app/lease/actions.ts</files>
  <action>
    Update `src/app/lease/actions.ts` to add authentication and user-scoping to every action:

    1. Add imports:
       - `import { auth } from '@clerk/nextjs/server'`
       - `import { and } from 'drizzle-orm'` (if not already imported)

    2. Create a helper at the top of the file (after imports):
       ```typescript
       async function requireAuth(): Promise<string> {
         const { userId } = await auth()
         if (!userId) throw new Error('Unauthorized')
         return userId
       }
       ```

    3. Update `createLease`:
       - Call `const userId = await requireAuth()` at the start
       - Add `userId` to the insert values: `{ ...insertData, userId }`

    4. Update `updateLease` (or equivalent edit action):
       - Call `const userId = await requireAuth()` at the start
       - Add user_id check to WHERE clause: `and(eq(leases.id, id), eq(leases.userId, userId))`
       - This ensures users can only update their own leases

    5. Update `deleteLease`:
       - Call `const userId = await requireAuth()` at the start
       - Add user_id check to WHERE clause: `and(eq(leases.id, id), eq(leases.userId, userId))`

    6. Update `getLease` (single lease fetch):
       - Call `const userId = await requireAuth()` at the start
       - Add user_id check to WHERE clause: `and(eq(leases.id, id), eq(leases.userId, userId))`
       - This prevents users from viewing other users' leases by ID

    7. Update `getLeases` (list all):
       - Call `const userId = await requireAuth()` at the start
       - Filter by `eq(leases.userId, userId)` to return only user's leases

    8. Update any market value actions (e.g., `createMarketValue`, `getLatestMarketValue`, `getMarketValueHistory`):
       - Call `const userId = await requireAuth()` at the start
       - For market value creation: verify the target lease belongs to the user before inserting
       - For market value reads: join through lease to verify ownership, or verify lease ownership first

    IMPORTANT: Do NOT rely on middleware alone. Every Server Action must independently verify auth(). This is defense-in-depth against CVE-2025-29927-type bypasses.

    Decision: Use `requireAuth()` helper pattern for consistent auth checks. Throws error (caught by existing ActionResult try/catch) rather than redirecting, because Server Actions are called from already-rendered pages.
  </action>
  <verify>
    - Every exported async function in actions.ts calls `requireAuth()` or `auth()`
    - `createLease` includes `userId` in insert values
    - `updateLease` and `deleteLease` have `and(eq(leases.id, id), eq(leases.userId, userId))` in WHERE
    - `getLeases` filters by `eq(leases.userId, userId)`
    - `npx tsc --noEmit` passes
  </verify>
  <done>All Server Actions verify authentication and scope data access to the authenticated user. No action can read, modify, or delete another user's data.</done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes
- Webhook handler at `/api/webhooks/clerk` verifies Svix signatures and upserts users
- Every Server Action in `src/app/lease/actions.ts` calls `requireAuth()` before database access
- All lease queries include `userId` in WHERE clause
- `createLease` associates new leases with authenticated user
</verification>

<success_criteria>
Webhook syncs Clerk user lifecycle to local database. All Server Actions are auth-gated and user-scoped. No data can be accessed without authentication. Users cannot access other users' data.
</success_criteria>

<output>
After completion, create `.planning/phases/05-authentication-and-multi-lease/05-03-SUMMARY.md`
</output>
