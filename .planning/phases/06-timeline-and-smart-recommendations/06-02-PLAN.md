---
phase: 06-timeline-and-smart-recommendations
plan: 02
type: tdd
wave: 2
depends_on: ["06-01"]
files_modified:
  - src/lib/recommendations/crossover-detection.ts
  - src/lib/recommendations/decision-window.ts
  - src/__tests__/lib/recommendations/crossover-detection.test.ts
  - src/__tests__/lib/recommendations/decision-window.test.ts
autonomous: true

must_haves:
  truths:
    - "Crossover points are detected when one scenario becomes cheaper than another"
    - "Recommendation distinguishes 'best option today' from 'better if you wait'"
    - "Crossover messages are human-readable and reference specific months"
  artifacts:
    - path: "src/lib/recommendations/crossover-detection.ts"
      provides: "Crossover point detection between scenario cost curves"
      exports: ["detectCrossovers", "CrossoverPoint"]
    - path: "src/lib/recommendations/decision-window.ts"
      provides: "Best-now vs wait recommendation logic"
      exports: ["generateRecommendation", "RecommendationResult"]
    - path: "src/__tests__/lib/recommendations/crossover-detection.test.ts"
      provides: "Tests for crossover detection accuracy"
      min_lines: 50
    - path: "src/__tests__/lib/recommendations/decision-window.test.ts"
      provides: "Tests for recommendation logic"
      min_lines: 50
  key_links:
    - from: "src/lib/recommendations/crossover-detection.ts"
      to: "src/lib/types/timeline.ts"
      via: "imports TimelineDataPoint"
      pattern: "import.*TimelineDataPoint.*from.*timeline"
    - from: "src/lib/recommendations/decision-window.ts"
      to: "src/lib/types/timeline.ts"
      via: "imports TimelineDataPoint"
      pattern: "import.*TimelineDataPoint.*from.*timeline"
---

<objective>
Build the crossover detection algorithm and decision window recommendation engine that identify when scenario rankings change and whether waiting improves the user's outcome.

Purpose: This is the "smart" in smart recommendations. Without crossover detection, the chart is just lines. Without decision-window logic, the user can't answer "should I act now or wait?" These pure functions are highly testable with defined inputs and outputs, making TDD the right approach.

Output: Tested pure functions for detecting scenario crossover points and generating "best now vs better if you wait" recommendations.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/06-timeline-and-smart-recommendations/06-RESEARCH.md
@.planning/phases/06-timeline-and-smart-recommendations/06-01-SUMMARY.md

@src/lib/types/timeline.ts
@src/lib/types/scenario.ts
@src/lib/utils/format-currency.ts
</context>

<feature>
  <name>Crossover Detection</name>
  <files>
    src/lib/recommendations/crossover-detection.ts
    src/__tests__/lib/recommendations/crossover-detection.test.ts
  </files>
  <behavior>
    Detects month when one scenario's cost crosses below another's cost.

    Types:
    - CrossoverPoint: { month: number, scenario: ScenarioType, overtakes: ScenarioType, message: string }
      - month: the month index where the crossover happens
      - scenario: the scenario that becomes cheaper
      - overtakes: the scenario it overtakes
      - message: human-readable like "Buyout becomes cheaper than returning after month 18"

    Function: detectCrossovers(data: TimelineDataPoint[]): CrossoverPoint[]

    Algorithm:
    - Compare costs of all active scenario pairs at consecutive months
    - A crossover occurs when scenario A was more expensive than B in month N-1 but becomes cheaper in month N
    - Only compare non-null scenario values (skip sellPrivately if null, skip extension if null)
    - Focus on crossovers involving the cheapest scenario at each month (don't report every pair -- only when the BEST option changes)
    - Return crossovers sorted by month ascending

    Simplified approach: Track which scenario is cheapest at each month. When the cheapest scenario changes, that's a crossover point.

    Expected test cases:
    - No crossovers when one scenario is always cheapest
    - Single crossover when buyout becomes cheaper than return at month 12
    - Multiple crossovers when rankings change twice
    - Null scenarios (sellPrivately = null) are ignored in comparison
    - Messages are human-readable with month reference
  </behavior>
  <implementation>
    1. Create src/lib/recommendations/crossover-detection.ts
    2. Import TimelineDataPoint from @/lib/types/timeline, ScenarioType from @/lib/types/scenario
    3. Helper: getCheapestScenario(point: TimelineDataPoint): { scenario: ScenarioType, cost: number } | null
       - Compare all non-null scenario costs in the data point
       - Return the scenario with lowest cost
       - Skip null values (sellPrivately, extension)
    4. Main: detectCrossovers(data: TimelineDataPoint[]): CrossoverPoint[]
       - For each consecutive pair of months, check if cheapest scenario changes
       - If it does, create a CrossoverPoint with descriptive message
       - Use formatOptionName from @/lib/utils/format-currency for display names in messages

    IMPORTANT: Use simple sequential comparison. Do NOT implement statistical change-point detection (PELT, etc.). The data is deterministic, not noisy.
  </implementation>
</feature>

<feature>
  <name>Decision Window Recommendation</name>
  <files>
    src/lib/recommendations/decision-window.ts
    src/__tests__/lib/recommendations/decision-window.test.ts
  </files>
  <behavior>
    Determines "best option today" vs "better if you wait."

    Types:
    - RecommendationResult: {
        bestNow: { scenario: ScenarioType, cost: number },
        bestOverall: { scenario: ScenarioType, cost: number, month: number },
        shouldWait: boolean,
        savings: number,      // How much waiting saves (0 if bestNow is best overall)
        message: string       // Human-readable recommendation
      }

    Function: generateRecommendation(data: TimelineDataPoint[]): RecommendationResult

    Logic:
    - bestNow: cheapest non-null scenario at month 0 (today)
    - bestOverall: cheapest non-null scenario across ALL months (the global minimum)
    - shouldWait: true if bestOverall.cost < bestNow.cost (waiting saves money)
    - savings: bestNow.cost - bestOverall.cost (positive = waiting saves this much)
    - message:
      - If shouldWait: "Waiting {N} months could save you {$X} â€” {scenario} becomes your best option in month {N}"
      - If not: "{scenario} is your best option today, and waiting won't improve it"

    Expected test cases:
    - bestNow matches bestOverall when today is already the cheapest point -> shouldWait = false
    - shouldWait = true when a future month has lower cost
    - savings calculated correctly as difference between now and best future
    - Message references correct month and formatted savings amount
    - Handles edge case: only 1 data point (month 0 = lease end)
    - Null scenarios excluded from comparison
  </behavior>
  <implementation>
    1. Create src/lib/recommendations/decision-window.ts
    2. Import TimelineDataPoint from @/lib/types/timeline
    3. Import formatCurrency, formatOptionName from @/lib/utils/format-currency
    4. Reuse getCheapestScenario helper (or import from crossover-detection)
    5. Main: generateRecommendation(data: TimelineDataPoint[]): RecommendationResult
       - Find cheapest at month 0
       - Scan all months for global cheapest
       - Compare and generate recommendation

    IMPORTANT: Use the $100 tie threshold from Phase 3 (checkForTie). If the savings from waiting is <= $100, treat it as "not worth waiting" since the difference is within the tool's precision tolerance.
  </implementation>
</feature>

<verification>
Run `npm test -- --run src/__tests__/lib/recommendations/` and all tests pass.
</verification>

<success_criteria>
- detectCrossovers correctly identifies month when cheapest scenario changes
- detectCrossovers returns empty array when rankings never change
- generateRecommendation correctly identifies bestNow vs bestOverall
- shouldWait is true only when future month is genuinely cheaper (beyond $100 threshold)
- Human-readable messages include month numbers and formatted dollar amounts
- Null scenarios are excluded from all comparisons
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/06-timeline-and-smart-recommendations/06-02-SUMMARY.md`
</output>
